<!DOCTYPE html>
<html>

<head>
    <title>Web3 Document Registry</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.6.1/dist/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
    <script src="https://cdn.ethers.io/lib/ethers-5.4.umd.min.js"></script>
</head>

<body>
    <h1>Web3 Document Registry and Timestamp</h1>
    <!-- <img src="./img/site_illustration.jpg"></img> -->
    <p>Register and verify documents on the blockchain.</p>
    <ul>
        <li><strong>Register documents on the blockchain</strong>: Upload a file and provide a name and description to
            register your document on the blockchain. This will give you proof of existence and authenticity of your
            document.</li>
        <li><strong>Search for documents on the blockchain</strong>: Upload a file to see if it is registered on the
            blockchain and by who. This will allow you to verify the validity and origin of a document.</li>
        <li><strong>View your registered documents</strong>: You can see a list of the documents you have registered on
            the blockchain with your connected address.</li>
    </ul>
    <p>This site can be <strong>useful for legal purposes</strong>, such as proving existence or ownership of a document
        at a given time.</p>
    <p>Please note that, when you upload a document, it does not leave your computer. A SHA256 signature of the
        file is computed locally and used for the document registry. A SHA256 signature is a unique digital
        fingerprint that is generated from the contents of a file. This kind of signature is used in many other
        applications, such as verifying the authenticity of software downloads, ensuring data integrity in
        databases, and securing online transactions</p>

    <button id="connectButton" onclick="connectWallet()">Connect Wallet</button>
    <button id="disconnectButton" style="display: none;" onclick="disconnectWallet()">Disconnect</button>

    <strong>
        <p id="networkStatus"></p>
    </strong>
    <p id="walletStatus"></p>
    <p id="connectionStatus"></p>

    <div id="connectedSection" style="display: none;">
        <h2>Document selection</h2>
        <p>Select a document to add or search on the registy.</p>
        </p>
        <label for="fileInput">Upload File:</label>
        <input type="file" id="fileInput" onchange="handleFile(this)" />
        <div id="progressBar" style="display: none;">
            <progress id="fileProgress" value="0" max="100"></progress>
            <p id="progressStatus">Loading...</p>
        </div>
        <p id="hashResult"></p>

        <h2>Search for a document on the registry</h2>
        <p>Look up for the selected document on the blockchain</p>
        <button id="searchDocumentButton" onclick="searchForDocumentOnTheBlockchain()" disabled="true">Search
            document</button>
        <p id="searchResult"></p>
        <h2>Register a document on the registry</h2>
        <p>Upload the selected document to the blockchain with a name and a description.</p>
        <p><strong>Note:</strong>A larger description will have an impact on the transaction costs. You cannot register
            the same document twice with the same address.</p>
        <div>
            <label for="fileName">File Name:</label>
            <br>
            <input type="text" id="fileName" name="fileName"></input>
        </div>
        <div>
            <label for="fileDescription">File Description:</label>
            <br>
            <textarea id="fileDescription" name="fileDescription" rows="4" cols="50"></textarea>
        </div>
        <div>
            <label for="donationAmount">Include a donation to support this website (optional):</label>
            <br>
            <input id="donationAmount" name="donationAmount" type="number" step="0.000000000000000001" min="0" value="0" oninput="validity.valid||(value='');"></input>
            <label id="networkCoinSymbol"></label>
        </div>
        <button id="addDocumentButton" onclick="addDocumentToContract()" disabled="true">Add Document</button>

        <p id="transactionInfo"></p>

        <h2>Your registered documents</h2>
        <p>Documents registered for the connected user.</p>
        <select id="fileDropdown" onchange="displayFileDetails()"></select>

        <p id="selectedFileHash"></p>
        <p id="selectedFileDescription"></p>
        <p id="selectedFileTimestamp"></p>

        <button onclick="getEventsAndRefresh()">Get your documents</button>
    </div>


    <script>
        //Get contract address and contract ABI from file
        var contractABI;
        var contractAddressBook;
        var contractAddress;

        fetch("contractABI.json")
            .then((response) => response.json())
            .then((data) => {
                contractABI = data;
            });
        fetch("contractAddress.json")
            .then((response) => response.json())
            .then((data) => {
                contractAddressBook = data;
            });

        //Variables    
        var emitedContractEvents;
        let isConnected = false;
        let documentHash;
        let currentAccount;
        let network;

        async function connectWallet() {
            // Check if there is an instance of web3 already present
            if (window.ethereum) {
                window.web3 = new Web3(window.ethereum);
                try {
                    // Reset connection status
                    const connectionStatus = document.getElementById("connectionStatus");
                    connectionStatus.innerText = "";

                    // Request access to the wallet
                    currentAccount = (await window.ethereum.request({ method: 'eth_requestAccounts' }))[0];
                    let chainID = await ethereum.request({ method: 'eth_chainId' });
                    networkChanged(chainID);
                    // Wallet access granted
                    console.log("Connection to wallet established!");
                    ethereum.on('chainChanged', (chainId) => {
                        networkChanged(chainId);
                    });

                    // Update UI
                    document.getElementById("connectButton").style.display = "none";
                    document.getElementById("disconnectButton").style.display = "inline";
                    if (network != "Unknown")
                        document.getElementById("connectedSection").style.display = "block";
                    isConnected = true;
                } catch (error) {
                    // User denied wallet access
                    const connectionStatus = document.getElementById("connectionStatus");
                    connectionStatus.innerText = "Connection to wallet was denied. Please approve the connection to continue.";
                    console.error("User denied wallet access");
                }
            } else {
                // Wallet not installed in the browser
                const walletStatus = document.getElementById("walletStatus");
                walletStatus.innerText = "No Ethereum wallet detected. Please install MetaMask or another Ethereum-compatible wallet.";
            }
        }

        function disconnectWallet() {
            // Reset UI
            document.getElementById("connectButton").style.display = "inline";
            document.getElementById("disconnectButton").style.display = "none";
            document.getElementById("connectedSection").style.display = "none";
            isConnected = false;
        }

        function networkChanged(chainID) {
            const networkStatus = document.getElementById("networkStatus");
            const networkCoinSymbol = document.getElementById("networkCoinSymbol");
            network = nameOfConnectedNetwork(chainID);

            networkStatus.innerText = "Connected network: " + network;
            networkCoinSymbol.innerText = SymbolOfConnectedNetwork(chainID);
            contractAddress = contractAddressBook[network];

            if (network === "Unknown") {
                document.getElementById("connectedSection").style.display = "none";
                networkStatus.innerText += ". Please change to a supported network.";
            }
            else
                document.getElementById("connectedSection").style.display = "block";

            console.log("Changed network to: " + network + ". CONTRACT ADDRESS " + contractAddress);
        }

        function handleFile(fileInput) {
            const progressBar = document.getElementById("progressBar");
            const progressStatus = document.getElementById("progressStatus");
            const hashResult = document.getElementById('hashResult');
            const transactionInfo = document.getElementById('transactionInfo');
            const fileNameInput = document.getElementById('fileName');
            const searchDocumentButton = document.getElementById('searchDocumentButton');

            hashResult.innerText = "";
            addDocumentButton.disabled = true;
            searchDocumentButton.disabled = true;

            const file = fileInput.files[0];

            const reader = new FileReader();
            reader.onloadstart = function (event) {
                progressBar.style.display = "block";
                fileInput.disabled = true;
            };
            reader.onprogress = function (event) {
                if (event.lengthComputable) {
                    const percentLoaded = Math.round((event.loaded / event.total) * 100);
                    progressBar.value = percentLoaded;
                    progressStatus.innerText = `Loading... ${percentLoaded}%`;
                }
            };
            reader.onload = function (event) {
                const fileData = event.target.result;
                const wordArray = CryptoJS.enc.Utf8.parse(fileData);
                const hash = CryptoJS.SHA256(wordArray);
                documentHash = '0x' + hash.toString().substring(0, 64);;
                hashResult.innerText = `Hash of the file: ${hash.toString()}`;
                fileNameInput.value = file.name;

                // Reset progress bar and enable input
                progressBar.style.display = "none";
                progressBar.value = 0;
                fileInput.disabled = false;
                addDocumentButton.disabled = false;
                searchDocumentButton.disabled = false;
            };
            reader.readAsDataURL(file);
        }

        /*Functions for contract interaction*/
        async function addDocumentToContract() {
            try {
                const addDocumentButton = document.getElementById('addDocumentButton');
                const transactionInfo = document.getElementById('transactionInfo');
                const documentName = document.getElementById('fileName').value;
                const documentDescription = document.getElementById('fileDescription').value;
                let donationAmount = document.getElementById("donationAmount").value;
                let donationAmountInWei;
                let etherscanLink;

                addDocumentButton.disabled = true;

                const account = currentAccount;
                const contract = await getContract();
                // web3.eth.handleRevert = true;


                //Ensure the validity of the donation amount
                //donationAmount = donationAmount.replace(',','.'); //<-Already done by element.value
                let parsedAmount = parseFloat(donationAmount);
                if (isNaN(parsedAmount))
                {
                    console.log("Failed to parse the donation amount. Using ZERO as donation value.");
                    donationAmount = "0";
                }

                //Convert to WEI or equivalent to call the contract function
                donationAmountInWei = ethers.utils.parseEther(donationAmount);

                await contract.methods.addDocument(documentHash, documentName, documentDescription).send({ from: account, value: donationAmountInWei })
                    .on('transactionHash', function (hash) {
                        console.log('Transaction Hash: ', hash);
                        etherscanLink = generateEtherscanLink(hash);
                        transactionInfo.innerHTML = "Transaction sent. Waiting for confirmation. " + etherscanLink;
                    })
                    .once('confirmation', function (confirmationNumber, receipt) {
                        console.log('Confirmation Number: ', confirmationNumber);
                        if (receipt.status == 1)
                            transactionInfo.innerHTML = "Document added to the blockchain. " + etherscanLink
                    })
                    .on('error', function (error) {
                        console.error('Transaction error: ', error);
                        transactionInfo.innerHTML = "Transaction error! " + etherscanLink;
                    });

            } catch (error) {
                console.error('Error when calling AddDocumentToContract:', error);
                //Skip if on error has already been called.
                if (!transactionInfo.innerHTML.includes("error"))
                    transactionInfo.innerHTML = "Transaction failed! " + etherscanLink;
            }
            finally {
                addDocumentButton.disabled = false;
            }
        }

        /*Registered documents management*/
        async function getEventsAndRefresh() {
            try {
                const dropdown = document.getElementById("fileDropdown");

                const account = currentAccount;
                const contract = await getContract();

                // Listen to the event DocumentAdded
                const myEvent = contract.events.DocumentAdded({ filter: { user: account } })
                    .on('data', function (event) {
                        const option = createOptionFromEvent(event);
                        dropdown.add(option);
                    })
                    .on('error', function (error) {
                        console.error('Error getting contract events:', error);
                    });

                // Access previous events
                emitedContractEvents = await contract.getPastEvents('DocumentAdded', {
                    filter: { user: account },
                    fromBlock: 0,
                    toBlock: 'latest'
                });

                dropdown.innerHTML = "";

                emitedContractEvents.forEach(event => {
                    const option = createOptionFromEvent(event);
                    dropdown.add(option);
                });

                displayFileDetails();

            } catch (error) {
                console.error('Error getting contract events to update the registry:', error);
            }
        }

        async function searchForDocumentOnTheBlockchain() {
            try {
                const searchResult = document.getElementById('searchResult');
                let contract = await getContract();

                const documentEvents = await contract.getPastEvents('DocumentAdded', {
                    filter: { hash: documentHash },
                    fromBlock: 0,
                    toBlock: 'latest'
                });

                if (documentEvents.length === 0) {
                    searchResult.innerText = "This document is not on the blockchain.";
                } else {
                    searchResult.innerText = "Document registered by: \n";

                    documentEvents.forEach(event => {
                        const eventInfo = `\nUser: ${event.returnValues.user}, 
                                        Document Name: ${event.returnValues.documentName}, 
                                        Description: ${event.returnValues.description}, 
                                        Timestamp: ${new Date(parseInt(event.returnValues.timestamp) * 1000).toLocaleString()}\n`;
                        searchResult.innerText += eventInfo;
                    });
                }
            } catch (error) {
                console.error('Error searching for document on the blockchain:', error);
            }
        }

        function displayFileDetails() {
            const fileDropdown = document.getElementById('fileDropdown');
            const selectedOption = fileDropdown.options[fileDropdown.selectedIndex];
            const selectedFileHash = document.getElementById('selectedFileHash');
            const selectedFileDescription = document.getElementById('selectedFileDescription');
            const selectedFileTimestamp = document.getElementById('selectedFileTimestamp');

            if (selectedOption && selectedOption.value) {
                const optionValue = JSON.parse(selectedOption.value);
                selectedFileHash.innerText = `File Hash: ${optionValue.hash}`;
                selectedFileDescription.innerText = `File Description: ${optionValue.description}`;

                const timestamp = new Date(optionValue.timestamp * 1000);
                const formattedTimestamp = timestamp.toLocaleString();
                selectedFileTimestamp.innerText = `Timestamp: ${formattedTimestamp}`;
            } else {
                selectedFileHash.innerText = "";
                selectedFileDescription.innerText = "";
                selectedFileTimestamp.innerText = "";
            }
        }

        /*Auxiliary functions*/
        function generateEtherscanLink(transactionHash) {
            let prefix = "";
            if (network === "Ethereum Goerli")
                prefix = "goerli.";
            else if (network === "Ethereum Sepolia")
                prefix = "sepolia."
            const etherscanURL = `https://${prefix}etherscan.io/tx/${transactionHash}`;
            const linkHTML = `<a href="${etherscanURL}" target="_blank">View Transaction on Etherscan</a>`;
            return linkHTML;
        }

        function createOptionFromEvent(event) {
            const option = document.createElement('option');
            const optionValue = {
                hash: event.returnValues.hash,
                description: event.returnValues.description,
                timestamp: event.returnValues.timestamp
            };
            option.text = event.returnValues.documentName;
            option.value = JSON.stringify(optionValue); // Convertir a cadena
            return option;
        }

        async function getContract() {
            let contract;
            contract = new web3.eth.Contract(contractABI, contractAddress);
            return contract;
        }

        function nameOfConnectedNetwork(chainID) {
            let name;
            switch (chainID) {
                case "0x5":
                    name = "Ethereum Goerli";
                    break;
                case "0x1":
                    name = "Ethereum Mainnet";
                    break;
                case "0xaa36a7":
                    name = "Ethereum Sepolia";
                    break;
                case "0x89":
                    name = "Polygon";
                    break;
                case "0x13881":
                    name = "Polygon Mumbai";
                    break;
                default:
                    name = "Unknown";
                    break;
            }
            return name;
        }

        function SymbolOfConnectedNetwork(chainID) {
            let symbol;
            switch (chainID) {
                case "0x5":
                    symbol = "Goerli ETH";
                    break;
                case "0x1":
                    symbol = "ETH";
                    break;
                case "0xaa36a7":
                    symbol = "Sepolia ETH";
                    break;
                case "0x89":
                    symbol = "MATIC";
                    break;
                case "0x13881":
                    symbol = "Mumbai MATIC";
                    break;
                default:
                    symbol = "Unknown";
                    break;
            }
            return symbol;
        }

    </script>
</body>

</html>